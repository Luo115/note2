/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80026
 Source Host           : localhost:3306
 Source Schema         : note2

 Target Server Type    : MySQL
 Target Server Version : 80026
 File Encoding         : 65001

 Date: 05/03/2023 01:04:45
 
	由于存在emoji字符，需要使用utfmb4编码，有的数据库版本不支持排序规则utf8_general_ai_ci，修改为utf8mb4_bin（后者大小写敏感）
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` smallint UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键，无符号自增',
  `title` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '标题',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL COMMENT '内容',
  `completionTime` datetime NULL DEFAULT NULL COMMENT '完成时间',
  `updateTime` datetime NULL DEFAULT NULL COMMENT '最后一次更新时间',
  `category` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '所属类别',
  `reserved01` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '保留字段01',
  `reserved02` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '保留字段02',
  `reserved03` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '保留字段03',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 35 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, '动态代理', '（JDK自带的）\n	1.定义一个接口，写一个实现类\n	2.写一个类实现InvocationHandler接口\n	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        		System.out.println(\"方法执行前代理\");\n        		Object invoke = method.invoke(target, args);\n        		System.out.println(\"方法执行后代理\");\n        		return invoke;\n   	 }	target就是这个类的一个属性，就好比静态代理，但这个target是一个object，也就是说\n这个方法不特用于某个类，即所谓的“动态”\n	3.使用时：\n	某个Interface a = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader()\n					, target.getClass().getInterfaces(), this);\n	再调用a.method 就会有重写的invoke方法中代理的效果', '2023-02-25 00:32:58', '2023-02-26 00:30:29', 'JAVA', NULL, NULL, NULL);
INSERT INTO `article` VALUES (2, '双亲委派机制', '| 方法         | 抛出异常  | 返回特定值 | 阻塞   | 阻塞特定时间         |\r\n| ------------ | --------- | ---------- | ------ | -------------------- |\r\n| 入队         | add(e)    | offer(e)   | put(e) | offer(e, time, unit) |\r\n| 出队         | remove()  | poll()     | take() | poll(time, unit)     |\r\n| 获取队首元素 | element() | peek       | 不支持 | 不支持               |\r\n\r\n阻塞队列区别于其他类型的队列的最主要的特点就是“阻塞”这两个字！\r\n阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来。\r\n实现阻塞最重要的两个方法是 take 方法和 put 方法。\r\n\r\n是线程安全的！  \r\n\r\n    put() 一直放 满了就阻塞等待  ---->   产品  产品  产品  产品  产品  产品  产品  ---->   take()一直取，取不到就阻塞等待\r\n\r\n坑：@Test下的方法new多个Thread实现多消费者多生产者 循环生产产品，将会失败。原因未知，猜测是因为@Test标注的\r\n方法仍是一个普通方法，虽然new了很多Thread在无限循环跑，但是该方法跑完一切就结束了！\r\n改为main方法后成功！', '2023-02-25 00:33:29', '2023-02-26 00:33:32', 'JAVA', NULL, NULL, NULL);
INSERT INTO `article` VALUES (3, '垃圾回收GC', '\n主要回收的是\n\n堆区：线程共享，放创建的对象的地方\n\n方法区：保存类的一些属性\n\n\n\n**标记-清除（Mark-Sweep）算法**：\n\n标记清除后会产生大量不连续的内存碎片\n\n\n\n**新生代（Young generation）**：绝大多数最新被创建的对象都会被分配到这里，由于大部分在创建后很快变得不可达，很多对象被创建在新生代，然后“消失”。对象从这个区域“消失”的过程我们称之为：**Minor GC** 。\n\n**老年代（Old generation）**：对象没有变得不可达，并且从新生代周期中存活了下来，会被拷贝到这里。其区域分配的空间要比新生代多。也正由于其相对大的空间，发生在老年代的GC次数要比新生代少得多。对象从老年代中消失的过程，称之为：**Major GC** 或者 **Full GC。**\n\n**持久代（Permanent generation）**也称之为 **方法区（Method area）**：用于保存类常量以及字符串常量。注意，这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生GC。发生在这个区域的GC事件也被算为 Major GC 。只不过在这个区域发生GC的条件非常严苛\n\n\n\n两个假说：\n\n***绝大多数对象都是朝生夕灭的。***\n\n***熬过越多次垃圾收集过程的对象就越难以消亡。***\n\n👇\n\n**标记-复制算法：**\n	新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。\n\n假说：\n\n***跨代引用相对于同代引用来说仅占极少数。***\n\n👇\n\n解决老年代引用新生代的问题，在老年代种维护一个记忆集，标识出跨代引用。\n\n\n\n老年代有个**标记-整理**算法：\n\n对存活的标记，然后整理成连续的空间。', '2023-03-03 17:53:45', '2023-03-04 21:04:14', 'JAVA', NULL, NULL, NULL);
INSERT INTO `article` VALUES (35, 'BlockingQueue阻塞队列', '| 方法         | 抛出异常  | 返回特定值 | 阻塞   | 阻塞特定时间         |\n| ------------ | --------- | ---------- | ------ | -------------------- |\n| 入队         | add(e)    | offer(e)   | put(e) | offer(e, time, unit) |\n| 出队         | remove()  | poll()     | take() | poll(time, unit)     |\n| 获取队首元素 | element() | peek       | 不支持 | 不支持               |\n\n阻塞队列区别于其他类型的队列的最主要的特点就是“阻塞”这两个字！\n阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来。\n实现阻塞最重要的两个方法是 take 方法和 put 方法。\n\n是线程安全的！  \n\n    put() 一直放 满了就阻塞等待  ---->   产品  产品  产品  产品  产品  产品  产品  ---->   take()一直取，取不到就阻塞等待\n\n坑：@Test下的方法new多个Thread实现多消费者多生产者 循环生产产品，将会失败。原因未知，猜测是因为@Test标注的\n方法仍是一个普通方法，虽然new了很多Thread在无限循环跑，但是该方法跑完一切就结束了！\n改为main方法后成功！', '2023-03-04 21:05:17', NULL, 'JAVA', NULL, NULL, NULL);
INSERT INTO `article` VALUES (36, '锁🔒', 'AQS：AbstractQueuedSynchronizer\n\nCAS：Compare And Swap：CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。\n\n\n\n---\n\n**可重入锁：**\n	public synchronized void test1() { \n 	   xxxxxx;\n 	   test2();\n	}\n	public synchronized void test2() { \n  	     ……\n	}\n	如果是不可重入锁，两个同步方法，调用test1，此时拥有该对象的锁，test1调用了test2，又需要该对象的锁，\n	相当于开始等待自己释放锁，形成死锁。\n	synchronized和ReentrantLock就是可重入锁，没有这种问题。\n\n**自旋锁：**\n	对自旋锁的申请者，将会一直自旋尝试获取！    而互斥锁，拿不到锁就直接睡眠了！\n	好处是 减少线程上下文切换的消耗，\n	缺点是 循环会消耗 CPU。\n\n---\n\n**公平锁：** 排队\n\n**非公平锁：** 插队，失败再排队。Synchronize和默认Lock就是非公平锁\n\n---\n\n**乐观锁：**认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。可以通过CAS算法实现，或者加版本号。\n\n**悲观锁：**不管什么情况都先加锁，确保数据线程安全，Synchronize和Lock都是悲观锁。', '2023-03-04 21:14:33', NULL, 'JAVA', NULL, NULL, NULL);
INSERT INTO `article` VALUES (37, 'jdk1.8新特性', '`jdk1.8之后，添加了默认方法，即default修饰的方法，主要是以前的一些接口想添加功能，需要修改所有的实现类！！现在可以在接口中添加default方法了，其子类都可以使用~`\n\n### Lambda\n\n常用于传参时，需要接口的情况，并且必须是一个函数式接口！\n\n格式： () -> {}\n\n例如，Spring boot中，启动时执行方法\n\n```java\n@Bean\nCommandLineRunner init(StorageService storageService){\n    return args -> storageService.init();\n}\n```\n\n此处 返回的CommandLineRunner是一个接口\n\n```java\n@FunctionalInterface\npublic interface CommandLineRunner {\n    void run(String... args) throws Exception;\n}\n```\n\n\n\n这样会创建一个匿名类继承CommandLineRunner，返回出去。\n\n**注意这里的参数args是必须的，名字无所谓，也可以不使用，但是参数数量一定要对上！**\n\n\n\n\n\n事实上，lambda表达式还可以作为变量\n\n```java\n	CommandLineRunner c = (args1) -> {  //do something...};\n```\n\n\n\n\n\n如果觉得Lambda表达式还不够简洁，那么使用==方法引用==吧！\n\n几种常见形式：\n\n- 类名::静态方法\n- 对象::实例方法\n- 类名::实例方法\n\n\n\n最经典的：\n\n```java\nList<String> list = new ArrayList<>();\nlist.forEach(System.out::println);\n```\n\n同样的是要满足传参和返回值的对应问题！（如上代码，forEach需要的是输入一个参数，没有返回值，刚好对应println方法！）\n\n\n\n\n\n### Stream流\n\n流主要是用来更==简洁==地处理数据的\n\n#### 创建流\n\n```java\n//Collection接口\n    Collection collection = new ArrayList();\n    Stream stream = collection.stream();\n    Stream parallelStream = collection.parallelStream();\n\n    //数组\n    A[] a = new A[2];\n    Stream<A> stream1 = Arrays.stream(a);\n\n    //Stream类的of方法\n    //of()源码发现是return Arrays.stream(values);\n    Stream<Object> stream2 = Stream.of();\n\n    //iterate()，创建一个无限流\n    Stream<Integer> stream3 = Stream.iterate(1, new UnaryOperator<Integer>() {\n        @Override\n        public Integer apply(Integer integer) {\n            return ++integer;\n        }\n    });\n\n    //generate方法，创建的也是无限流\n    Stream<Object> stream4 = Stream.generate(new Supplier<Object>() {\n        @Override\n        public Object get() {\n            return Math.random();\n        }\n    });\n    stream4.forEach(System.out::println);\n}\n```\n\n\n\n其中 iterate方法有个参数需要UnaryOperator<>()接口，挺新奇的。\n\n它继承自Function，因此拥有supply()方法，满足@FunctionalInterface的要求\n\n但它自带的这个静态方法返回的竟然是自己的一个实现\n\n```java\npackage java.util.function;\n\n/**\n * Represents an operation on a single operand that produces a result of the\n * same type as its operand.  This is a specialization of {@code Function} for\n * the case where the operand and result are of the same type.\n *\n * <p>This is a <a href=\"package-summary.html\">functional interface</a>\n * whose functional method is {@link #apply(Object)}.\n *\n * @param <T> the type of the operand and result of the operator\n *\n * @see Function\n * @since 1.8\n */\n@FunctionalInterface\npublic interface UnaryOperator<T> extends Function<T, T> {\n\n    /**\n     * Returns a unary operator that always returns its input argument.\n     *\n     * @param <T> the type of the input and output of the operator\n     * @return a unary operator that always returns its input argument\n     */\n    static <T> UnaryOperator<T> identity() {\n        return t -> t;\n    }\n}\n```\n\n试了一下，好像就是原封不动的返回输入值。。。。\n\n```java\n	UnaryOperator<Object> identity = UnaryOperator.identity();\n	Object apply = identity.apply(\"1997年，我学会了开汽车，上坡下坡压死了一千多~\");\n	System.out.println(apply);\n```\n\n\n\n#### 操作流\n\n中间操作（intermediate operation）\n\n下面是一些常见的，大部分都是见名知意的方法~\n\n这里这个==peek==比较特殊，peek在csgo里是对枪时在掩体后疯狂进出的操作 \n\n其英文原意也就是偷窥的意思\n\n此处就是在你一顿操作之后还剩下的元素，打印出来~，***也没啥用~***\n\n```java\nStream<String> names = Stream.of(\"Alice\", \"Bob\", \"Charley\", \"David\");\n\nnames.distinct()\n        .map(String::toUpperCase)	//对每个元素进行的操作\n        .dropWhile(s -> s.matches(\"[0-9]*\"))  //如果满足这个正则就丢弃掉\n        .filter(s -> s.startsWith(\"A\"))	//过滤~\n        .peek(System.out::print)\n        .limit(4)	//取前4个\n    	.skip(2)	//跳过前2个~	\n        .forEach(System.out::println);\n```\n\n哦哦还有一个\n\n*flatMap--- 接收一个函数作为参数,将流中的每个值都换成另一个流,然后把所有流连接成一个流*\n\n\n\n#### 终止操作\n\n```java\n查找与匹配\nallMatch---检查是否匹配所有元素\nanyMatch---检查是否至少匹配一个元素\nnoneMatch---检查是否没有匹配所有元素\nfindFirst---返回第一个元素\nfindAny---返回当前流中的任意元素\ncount---放回流中元素的总个数\nmax---返回流中最大值\nmin---返回流中最小值\n\n归约:\nidentity：初始值；accumulator：归约方法\nreduce(T identity, BinaryOperator<T> accumulator)\nreduce(BinaryOperator<T> accumulator)\n可以将流中元素反复结合起来,得到一个值\nOptional<String> reduce = Stream.of(\"one\", \"two\", \"three\", \"four\")\n                .filter(e -> e.length() > 3)\n                .peek(e -> System.out.println(\"Filtered value: \" + e))\n                .map(String::toUpperCase)\n                .peek(e -> System.out.println(\"Mapped value: \" + e))\n    			//将结果归约，依次连接字符串\n                .reduce((s, s2) -> Strings.concat(s, s2));\n        if(reduce.isPresent()){	//如果结果存在\n            System.out.println(\"reduce = \" + reduce);\n        }else {\n            System.out.println(\"reduce is null\");\n        }\n\n```\n\n\n\n### Optional\n\n如果一个值可能返回null，可以用这个包装一下\n\n```java\n//用于解决空指针异常\n//Optional 容器类的常用方法\n/**Optional.of(T t) :创建一个optional实例\n * Optional.empty() : 创建一个空的Optional实例\n * Optional.ofNullable(T t):若t不为null,创建Optional实例,否则创建空实例\n * isPresent(T t) : 判断是否包含值\n * orElse(T t) : 如果调用对象包含值,返回该值,否则返回t\n * orElseGet(Supplier s) : 如果调用对象包含值,返回该值,否则返回s获取的值\n * map(Function f) : 如果有值对其处理,并返回处理后的Optional,否则返回Optional.empty()\n * flatMap(Function mapper) : 与map类似,要求返回值必须是Optional\n */\n```\n\n', '2023-03-04 21:15:25', NULL, 'JAVA', NULL, NULL, NULL);
INSERT INTO `article` VALUES (38, 'ThreadPool', '线程池（thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。\n\n而线程池维护着多个线程，对线程统一管理。\n\n### 1.六大参数\n\n``` java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n```\n\n**一个例子：**\n\n```java\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n                4,  //无论有没有任务都创建4个线程\n                10, //超过4个任务就会创建新的进程，但是不 超过10个\n                10, //核心线程之外的线程如果10分钟没用就会回收！\n                TimeUnit.MINUTES,\n                new ArrayBlockingQueue(10), //用来存放未被执行的任务，如果设置的很大，maximumPoolSize就没啥用了！\n                Executors.defaultThreadFactory()\n        );\n```\n\n### 2.四种拒绝策略\n#### AbortPolicy（终止策略）\n\n```java\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n                4,  //无论有没有任务都创建4个线程\n                10, //超过4个任务就会创建新的进程，但是不超过10个\n                10, //核心线程之外的线程如果10分钟没用就会回收！\n                TimeUnit.MINUTES,\n                new ArrayBlockingQueue(1), //用来存放未被执行的任务，如果设置的很大，maximumPoolSize就没啥用了！\n                Executors.defaultThreadFactory(),\n                new ThreadPoolExecutor.AbortPolicy()\n        );\n        for (int i = 0; i < 15; i++) {\n            threadPoolExecutor.execute(() -> {\n                        System.out.println(Thread.currentThread().getName());\n                        while(true); //让线程一直跑，腾不出手来解决其他线程！\n                    }\n            );\n        }\n```\n线程池满了之后直接抛出异常！\n#### DiscardPolicy（抛弃策略）\n跑不了的直接抛弃掉！\n#### CallerRunPolicy（调用者运行策略）\n自己跑不完就丢给调用自己的main线程去跑！\n### 3.如何何理配置线程池\n使用线程池时通常我们可以将执行的任务分为两类：\n\n- cpu 密集型任务\n- io 密集型任务\n\ncpu 密集型任务，需要线程长时间进行的复杂的运算，这种类型的任务需要少创建线程（以CPU核数+1为准），过多的线程将会频繁引起上文切换，降低任务处理速度。\n\n而 io 密集型任务，由于线程并不是一直在运行，可能大部分时间在等待 IO 读取/写入数据，增加线程数量可以提高并发度，尽可能多处理任务。\n\n****配置线程池最好的方式是可以动态修改线程池配置，****\n\n****例如调用线程池的threadPoolExecutor.setCorePoolSize();方法，****\n\n**搭配分布式配置中心可以随着运行场景动态的修改核心线程数等功能。**\n\n\n\n**另外，用完记得调用ThreadPool.shutdown()！**\n\n', '2023-03-04 21:31:26', NULL, 'JAVA', NULL, NULL, NULL);
INSERT INTO `article` VALUES (39, '整数反转', '要求：字面意思\n\n==方法一：==\n\n转成字符串后调用StringBuilder的reverse方法\n\n```java\n    int i = 1234;\n    //转化成字符串\n    String s = Integer.toString(i);\n    //构建StringBuilder，因为String类是没有reverse方法的~\n    StringBuilder stringBuilder = new StringBuilder(s);\n    //调用reverse方法\n    StringBuilder reverse = stringBuilder.reverse();\n    System.out.println(reverse); \n```\n\n==方法二==\n\n```java\n    int num = 1234;\n    int result = 0;\n    while (num != 0){\n        result = result*10+num%10;\n        num/=10;\n    }\n    System.out.println(\"反转后整数为：\"+result);\n```\n\n', '2023-03-04 21:34:00', NULL, '算法', NULL, NULL, NULL);
INSERT INTO `article` VALUES (41, '恰好大点的2的倍数', '```java\nstatic final int tableSizeFor(int cap) {\n    //判断cap是否是2的倍数!!!如果是，直接返回cap \n    //原理是，如果是2的倍数，那二进制一定只有一个1，再和cap-1按位与一定是0！\n    if ((cap & cap - 1) == 0) {\n        return cap;\n    }\n    int n = cap;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return n + 1;\n}\n```\n\n', '2023-03-04 21:35:59', NULL, '算法', NULL, NULL, NULL);
INSERT INTO `article` VALUES (42, '快排算法', '```java\npublic static void quickSort(int[] ints, int first, int last) {\n        if (first >= last) {\n            return;\n        }\n        /**5,3,7,6,4,1,0,2,9,10,8。\n        5,3,2,6,4,1,0,7,9,10,8\n        5,3,2,0,4,1,6,7,9,10,8\n        5,3,2,l,4,1,R,7,9,10,8\n        1,3,2,0,4,*5*,6,7,9,10,8\n        */\n        //第一次排序确定支点，分成两部分，左边全比它小，右边全比它大\n        int pivot = sort(ints, first, last);\n        //递归调用，左边部分的\n        quickSort(ints, 0, pivot - 1);\n        //递归调用，右边部分\n        quickSort(ints, pivot + 1, last);\n\n    }\n\n    public static int sort(int[] ints, int first, int last) {\n        int head = first;\n        int tail = last;\n        int pivot = ints[first];\n        int temp;\n\n        //如果左右指针未相撞，则循环\n        while (head < tail) {\n            //先从右至左，将右指针停到 比pivot 小的数组下标\n            while (head < tail && ints[tail] > pivot) {\n                tail--;\n            }\n            //左到右，将左指针停到 比pivot 大的数组下标\n            while (head < tail && ints[head] <= pivot) {\n                head++;\n            }\n            //此时指针还未相撞，则调换左右指针下标位置的值\n            if (head < tail) {\n                temp = ints[head];\n                ints[head] = ints[tail];\n                ints[tail] = temp;\n            }\n        }\n        //此时跳出循环，说明左右指针相撞，将右指针对应的下标和最开始选的pivot互换\n        //这里pivot我们最开始选的就是first位置，为啥要这么写只是不想多个变量swap了\n        ints[first] = ints[tail];\n        ints[tail] = pivot;\n        return tail;\n    }\n```', '2023-03-04 21:37:10', NULL, '算法', NULL, NULL, NULL);
INSERT INTO `article` VALUES (43, '二分查找法', '```java\n    /**\n     *  二分查找法\n     * @param ints 排好序的数组\n     * @param value 需要查找的值\n     */\n    static int binarySearch(int[] ints, int value) {\n        int middle = ints.length / 2;\n        int[] ints1;\n        if (ints[middle] == value) {\n            return ints[middle];\n        }\n        if (ints[middle] > value) {\n            ints1 = Arrays.copyOfRange(ints, 0, middle);\n        } else {\n            ints1 = Arrays.copyOfRange(ints, middle + 1, ints.length);\n        }\n        return binarySearch(ints1, value);\n    }\n```\n\n', '2023-03-04 21:37:59', NULL, '算法', NULL, NULL, NULL);
INSERT INTO `article` VALUES (44, '索引', '==**索引是有序的！**==\n\n因此可以在order by xxx 上建立索引，可以省去filesort排序的时间\n\nwhere + order by 就使用联合索引！\n\n\n\n**模糊查询：**\n\n例：where name like \'%[张，李]_\'  ：任意个字符 + ‘张’或者‘李’ + 单个字符\n\n\n\n**MyISAM ：非聚簇索引，数据和索引分开，且不支持事务**\n\n**Innodb：聚簇索引，数据和索引一起，支持事务**\n\n\n\n**索引分类**\n\n1、普通索引 和 唯一索引\n\n- 普通索引：MySQL 中的基本索引类型，允许在定义索引的列中插入 重复值 和 空值\n- 唯一索引：要求索引列的值必须 唯一，但允许 有空值\n  - 如果是组合索引，则列值的组合必须 唯一\n  - 主键索引是一种特殊的唯一索引，不允许 有空值\n\n2、单列索引 和 组合索引\n\n- 单列索引：一个索引只包含单个列，一个表可以有多个单列索引\n- 组合索引：在表的 多个字段 组合上 创建的 索引\n  - 只有在查询条件中使用了这些字段的 左边字段 时，索引才会被使用（最左前缀原则）\n\n3、全文索引\n\n- 全文索引 的类型为 fulltext\n- 在定义索引的 列上 支持值的全文查找，允许在这些索引列中插入 重复值 和 空值\n- 全文索引 可以在 char、varchar 和 text 类型的 列 上创建\n\n\n\n**怎么判断要不要加索引？**\n\n加索引：\n\n- 数据本身具有某种的性质，如：唯一性、非空性…\n- 频繁进行 分组或排序 的列；如果待排序的列有多个，可以建立 组合索引\n\n不加索引：\n\n- 经常更新的列\n- 列 的值类型 很少，如 性别\n- where 条件中用不到的列\n- 参与计算的列\n- 数据量小的表\n\n#### InnoDB 索引\n\n- 数据和索引都存储在一个文件中（.ibd）\n- 一般情况下，聚簇索引等同于主键索引；除 聚簇索引 外的所有索引 均称为 辅助索引\n- InnoDB（B+Tree）叶子节点中存储的键值为索引列的值\n  - 如果是聚簇索引，数据为整行记录（除了主键值）\n  - 如果是辅助索引，数据为该行的主键值\n- 每一张表都有一个聚簇索引\n  - 如果表中有定义主键，主键索引用作聚簇索引\n  - 如果表中没有定义主键，选择第一个不为 NULL 的唯一索引列用作聚簇索引\n  - 如果以上都没有，使用一个 6 字节长整形的隐式字段 ROWID （自增）用作聚簇索引\n- 根据在 辅助索引树 中获取的 主键id，再到 主键索引树 查询数据的过程 称为 回表 查询\n- 组合索引\n  - 遵循 最左匹配（最左前缀）原则：\n    - 使用 组合索引 查询时，MySQL 会一直向右匹配直至遇到范围查询（>、<、between、like）就停止匹配。\n  - 只有第一列是有序的，其它列都是无序的（最左匹配原则的原因）\n\n#### **组合索引**\n\n组合索引的三大优势：\n\n- 覆盖多个查询条件，如（a，b）索引可以覆盖查询 a = ? 或者 a = ? and b = ?；\n- 避免 SQL 的额外排序，提升 SQL 性能，如 WHERE a = ? ORDER BY b 这样的查询条件；\n- 利用组合索引包含多个列的特性，可以实现**覆盖索引**，提升 SQL 的查询性能\n\n\n\n==覆盖索引：== 即查询的字段 恰好在组合索引之内，而不需要回表！\n\n比如，如下情况\n\n你的查询\n\n```sql\n select * from xx where name = \'xiaoli\'\n```\n\n只有主键id索引，那么，会从主键索引中一条条取出数据比对\n\n如果对 `name` 加索引（即一条辅助索引，存储方式为name + id）\n\n**则会查询该索引，取得主键id，再去主键索引中取出数据，即回表**\n\n\n\n但是如果你的查询\n\n```sql\nselect name, gender, hobby from xx where.... #where后面是只要能应用到索引的条件~\n```\n\n**且有组合索引（name，gender，hobby），那么这个查询显然是不需要回表的~\n\n### 查询优化\n\n**阿里巴巴Java 开发手册**\n\n```\n【强制】 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度。\n\n说明： **索引的长度与区分度是一对矛盾体**，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，**可以使用 \ncount(distinct left(列名, 索引长度))/count(\\*)的区分度来确定。\n```\n\n```\n【推荐】 如果有 order by 的场景，请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。\n\n正例： where a=? and b=? order by c; 索引： a_b_c\n\n反例： 索引如果存在范围查询， 那么索引有序性无法利用，如： WHERE a>10 ORDER BY b; 索引 a_b 无 法排序\n```\n\n\n\n**最左匹配** 所谓最左原则指的就是如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，值得注意的是，当遇到范围查询(>、<、between、like)就会停止匹配。\n\n 假设，我们对(a,b)字段建立一个索引，也就是说，你where后条件为\n\n```sql\na = 1\na = 1 and b = 2\n是可以匹配索引的。\n```\n\n但是要注意的是~你执行\n\n```sql\nb= 2 and a =1\n也是能匹配到索引的,因为Mysql有优化器会自动调整a,b的顺序与索引顺序一致。\n```\n\n 相反的，你执行\n\n```sql\nb = 2\n就匹配不到索引了。\n```\n\n 而**你对(a,b,c,d)建立索引,where后条件为**\n\n```sql\na = 1 and b = 2 and c > 3 and d = 4\n```\n\n那么，**a,b,c三个字段能用到索引，而d就匹配不到。因为遇到了范围查询！**\n\n\n\n\n\n==场景一：==\n\n```sql\nSELECT * FROM table WHERE a = 1 and b = 2 and c = 3; \n```\n\n**(a,b,c)或者(c,b,a)或者(b,a,c)都可以，重点要的是将区分度高的字段放在前面，**\n\n\n\n==场景二：==\n\n```sql\nSELECT * FROM table WHERE a > 1 and b = 2; \n```\n\n对(b,a)建立索引。如果你建立的是(a,b)索引，**那么只有a字段能用得上索引，毕竟最左匹配原则遇到范围查询就停止匹配。**\n\n如果对(b,a)建立索引那么两个字段都能用上，优化器会帮我们调整where后a,b的顺序，让我们用上索引。\n\n\n\n==场景三：==\n\n```sql\nSELECT * FROM `table` WHERE a > 1 and b = 2 and c > 3; \n```\n\n(b,a)或者(b,c)都可以\n\n\n\n==场景四：==\n\n````sql\n SELECT * FROM `table` WHERE a = 1 ORDER BY b;\n````\n\n建立联合索引（a，b）\n\n```sql\nSELECT * FROM `table` WHERE a > 1 ORDER BY b; \n```\n\n对(a)建立索引，因为a的值是一个范围，这个范围内b值是无序的，没有必要对(a,b)建立索引。\n\n\n\n\n\n尽可能将范围查询转换成“等值”查询，如 “a>1 and a<5 and b>10” 可以写成“a in (1,2,3,4,5) and b > 10”，然后设置索引为 idx(a,b)。\n\n将“等值”条件放在最左边，按最左匹配就可以命中索引。', '2023-03-04 21:49:10', NULL, 'MySQL', NULL, NULL, NULL);
INSERT INTO `article` VALUES (45, 'SSM整合配置文件', '### 1.建表\n\n```mysql\ndrop table if exists books;\n\ncreate table books(\nbookID int not null auto_increment comment \'书id\',\nbookName varchar(100) not null comment \'书名\',\nbookCounts int not null comment \'数量\',\ndetail varchar (200) not null comment \'描述\',\nkey bookID(bookID)\n) engine=innodb default charset=utf8\n\ninsert into books(bookID,bookName,bookCounts,detail) values\n(1,\'Java\',1,\'从入门到放弃\'),\n(2,\'MySQL\',10,\'从删库到跑路\'),\n(3,\'Linux\',5,\'从进门到进牢\');\n```\n\n\n\n### 2.各种配置文件：\n\n#### applicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <import resource=\"spring-mapper.xml\" />\n    <import resource=\"spring-service.xml\"/>\n    <import resource=\"spring-mvc.xml\"/>\n\n</beans>\n```\n\n\n\n#### spring-mapper.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:property-placeholder location=\"classpath:ssm/database.properties\"/>\n\n\n    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <property name=\"driverClass\" value=\"${jdbc.driver}\"/>\n        <property name=\"jdbcUrl\" value=\"${jdbc.url}\"/>\n        <property name=\"user\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n        <!-- c3p0连接池的私有属性 -->\n        <property name=\"maxPoolSize\" value=\"30\"/>\n        <property name=\"minPoolSize\" value=\"10\"/>\n        <!-- 关闭连接后不自动commit -->\n        <property name=\"autoCommitOnClose\" value=\"false\"/>\n        <!-- 获取连接超时时间 -->\n        <property name=\"checkoutTimeout\" value=\"10000\"/>\n        <!-- 当获取连接失败重试次数 -->\n        <property name=\"acquireRetryAttempts\" value=\"2\"/>\n    </bean>\n\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"configLocation\" value=\"classpath:ssm/mybatis-config.xml\"/>\n     </bean>\n\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\n        <property name=\"basePackage\" value=\"com.haha.ssm.mapper\"/>\n    </bean>\n\n</beans>\n```\n\n#### spring-mvc.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n   http://www.springframework.org/schema/beans/spring-beans.xsd\n   http://www.springframework.org/schema/context\n   http://www.springframework.org/schema/context/spring-context.xsd\n   http://www.springframework.org/schema/mvc\n   https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!-- 配置SpringMVC -->\n    <!-- 1.开启SpringMVC注解驱动 -->\n    <mvc:annotation-driven />\n    <!-- 2.静态资源默认servlet配置-->\n    <mvc:default-servlet-handler/>\n    <!-- 3.配置jsp 显示ViewResolver视图解析器 -->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" >\n        <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" />\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n\n    <!-- 4.扫描web相关的bean -->\n    <context:component-scan base-package=\"com.haha.ssm.controller\" />\n\n</beans>\n```\n\n#### spring-service.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!-- 扫描service相关的bean -->\n    <context:component-scan base-package=\"com.haha.ssm.service\" />\n\n    <!--BookServiceImpl注入到IOC容器中-->\n    <bean id=\"bookServiceImpl\" class=\"com.haha.ssm.service.impl.BookServiceImpl\">\n        <property name=\"bookMapper\" ref=\"bookMapper\"/>\n    </bean>\n\n    <!-- 配置事务管理器 -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <!-- 注入数据库连接池 -->\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n\n    <!--结合AOP实现事务的织入-->\n    <!--配置事务通知-->\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        <!--给哪些方法配置事务-->\n        <!--配置事务的传播特性：new propagation -->\n        <tx:attributes>\n            <tx:method name=\"*\" propagation=\"REQUIRED\"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <!--配置事务切入-->\n    <aop:config>\n        <aop:pointcut id=\"txPointCut\" expression=\"execution(* com.haha.ssm.mapper.*.*(..))\"/>\n        <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/>\n    </aop:config>\n\n</beans>\n```\n\n\n\n#### mybatis-config.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<configuration>\n\n    <typeAliases>\n        <package name=\"com.haha.ssm.pojo\"/>\n    </typeAliases>\n\n\n    <mappers>\n        <mapper resource=\"ssm/mapper/BookMapper.xml\"/>\n    </mappers>\n\n</configuration>\n```\n\n#### BookMapper.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"com.haha.ssm.mapper.BookMapper\">\n\n    <insert id=\"addBook\" parameterType=\"book\">\n        insert into test.books (bookName,bookCounts,detail)\n        values (#{bookName},#{bookCounts},#{detail});\n    </insert>\n\n    <delete id=\"deleteBookByID\" parameterType=\"int\">\n        delete from test.books where bookID = #{bookID};\n    </delete>\n\n    <update id=\"updateBook\" parameterType=\"book\">\n        update test.books\n        set bookName = #{bookName},bookCounts = #{bookCounts},detail = #{detail}\n        where bookID = #{bookID};\n    </update>\n\n    <select id=\"findBookByID\" resultType=\"book\">\n        select * from test.books where bookID = #{bookID};\n    </select>\n\n    <select id=\"findAllBooks\"  resultType=\"book\">\n        select * from test.books;\n    </select>\n</mapper>\n```\n\n#### database.properties\n\n```properties\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/test?useSSL=true&useUnicode=ture&characterEncoding=utf8&serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=root\n```\n\n#### web.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    <!--DispatcherServlet-->\n    <servlet>\n        <servlet-name>DispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！-->\n            <param-value>classpath:ssm/applicationContext.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>DispatcherServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n    <!--encodingFilter-->\n    <filter>\n        <filter-name>encodingFilter</filter-name>\n        <filter-class>\n            org.springframework.web.filter.CharacterEncodingFilter\n        </filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>utf-8</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>encodingFilter</filter-name>\n        <url-pattern>/a</url-pattern>\n    </filter-mapping>\n\n    <!--Session过期时间-->\n    <session-config>\n        <session-timeout>15</session-timeout>\n    </session-config>\n\n</web-app>\n```\n\n---\n\n', '2023-03-04 21:51:31', NULL, 'JAVA', NULL, NULL, NULL);
INSERT INTO `article` VALUES (46, 'Linux常用命令', '\n\n* touch：创建文件\n* echo : 写东西 echo \'xxx\' >> a.txt，不存在会创建，存在则会追加\n* pwd：print work directory：打印当前目录\n* cp：拷贝\n* **who am i**：我是谁？\n* **whereis**：展示二进制文件、源文件、手册文件的位置。\n* su：switch user，切换账号\n* **ps**：process state (-aux)，查看进程，通常配合 grep 使用 ps aux | grep xx ;\n* **systemctl status firewalld**：查询防火墙状态 （start，stop，restart）\n* shift+PageUp/Down：前后翻页\n* **ifconfig** : 查看网络配置\n* 硬链接：ln 原文件 链接         与原文件指向同一个，相当于备份，原文件删除依旧能用\n* 软连接：ln -s(symbolic) 原文件 链接  	快捷方式\n* df 查看总磁盘信息 -h --> human readable； du 查看当前文件夹磁盘信息\n* kill -9 进程id : 强制结束进程 （killall -9 filename：按照文件名字结束进程）\n* source：在当前bash下刷新刚更改的配置文件（如刚修改了java的环境变量时，需刷新一下才能使用java命令）\n* tar -xzvf：x是extract提取，z是tar.gz，v是verbose，f不知道但是必选（可能是file）\n* tar -czvf + 目标文件 + 要打包的文件：c是create； 当有多个参数时，-f命令参数必须在最后一个，否则会报错，原因是 -f后面跟的是目标文件名称，如果-fc，则会把c当做源文件名称。\n* make：相当于安装，通常有一个makefile文件	如 make PREFIX=/usr/local/redis install 即安装redis到指定目录下\n* file：查看文件类型\n* **find**：查找文件，实例： find ./ -name \"*hi\"\n* scp：secure copy 安全复制\n* uname [选项]...  输出一组系统信息。如果不跟随选项，则视为只附加-s 选项。\n* lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。\n* nc是netcat的简写，是一个功能强大的网络工具，有着网络界的瑞士军刀美誉。nc命令在linux系统中实际命令是ncat，nc是[软连接](https://so.csdn.net/so/search?q=软连接&spm=1001.2101.3001.7020)到ncat\n* strace 是一个可用于诊断、调试和教学的 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。\n\n\n\nrpm -qa | grep java：查看java相关的软件包\n\n*rpm -e --nodeps*：卸载某个包\n\n\n\n\n\n\n\n***有关硬链接***：\n\n硬链接是指通过索引节点来进行链接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都会给它分配一个编号，这个编号被称为索引节点编号号(Inode Index)或者Inode，它是文件或者目录在一个文件系统中的唯一标识，文件的实际数据放置在数据区域（data block），它存储着文件重要参数信息，也就是元数据 （metadata），比如创建时间、修改时间、文件大小、属主、归属的用户组、读写权限、数据所在block号等，\n\n在删除源文件的时候，系统则将链接数减1，当链接数为0的时候，inode就会被系统回收，文件的内容才会被删除。\n\n### 查看文件\n\ncat , tac：普通查看，一个倒的一个正的\n\nmore ：常用的分页，空格翻页，没有向上翻。。。\n\nless：more的升级版，可以往前翻页！👍\n\nnl  ：带行号的查看，差不多等于cat -n\n\nhead：显示文件开头一些行的内容，默认显示文件前10行 -n参数指定行数\n\n**tail**：  1.显示文件最后一些行的内容，默认显示文件后10行 -n参数指定行数\n\n​			2.当文件增长时输出追加的数据，比如日志时时生成，(crtl+c终止显示) tail -f log_file\n\n​			3、加-f参数显示追加是数据时可以与-s参数配置，睡眠几秒在进行追加显示 tail -f -s 10 log_file	\n\n\n\n\n\n---\n\n\n\n### 搜索文件\n\n\n\n**1.find在指定目录下查找**\n\n```cobol\nfind path -name testfile\nfind /  -name nginx\nfind /  -name nginx* #模糊匹配 \nfind /  -mmin -20  #最近20分钟内修改的文件\nfind /  -mtime -1  #最近1天内修改的文件\n```\n\n**2.locate**\n\n```shell\nlocate nginx\n```\n\nlinux系统每天至少自动扫描一次文件，将结果保存到数据库，locate查的是数据库记录。locate查询比find要快，但最新文件如果在数据库中没有记录,是需要手动更新（updatedb命令）\n\n**3.which**\n\nwhich从环境变量文件（/etc/profile）中的path目录中查找，且which找的都是可执行文件。\n\n```bash\nwhich nginx\n```\n\n4.whereis\n\n与which类似查询可执行文件，whereis查询更多，会查找出相关的man文件 \n\n```cobol\nwhereis nginx\n```\n\n\n\n\n\n\n\n### 修改权限\n\nchmod（英文全拼：change mode）命令是控制用户对文件的权限的命令。\n\nLinux/Unix 的文件调用权限分为三级 : **文件所有者（Owner）、用户组（Group）、其它用户（Other Users）**\n\n参数如下\n\n- -c : 若该文件权限确实已经更改，才显示其更改动作\n- -f : 若该文件权限无法被更改也不要显示错误讯息\n- -v : 显示权限变更的详细资料\n- -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)\n\n#### 数字法：\n\nchmod rwx 文件（rwx用数字代替）\n\n例如：chmod 754 文件\n\n| r    | 读取权限，数字代号为 \"4\"     |\n| ---- | ---------------------------- |\n| w    | 写入权限，数字代号为 \"2\"     |\n| x    | 执行权限，数字代号为 \"1\"     |\n| -    | 不具任何权限，数字代号为 \"0\" |\n\n\n\n通常我们以 Vim 编辑 Shell 文件批处理文件后，文件权限通常是 rw-rw-r--（644），那么，如果要将该文件变成可执行文件，并且不让其他人修改此文件，则只需将此文件的权限该为 rwxr-xr-x（755）即可。\n\n\n\n#### 字母法：\n\nchmod u/g/o/a +/-/= rwx 文件\n\n例如：chmod u + r（给u增加可读权限）\n\n其中：\n\n| **[ u/g/o/a ]** | **含义**                                                  |\n| --------------- | --------------------------------------------------------- |\n| u               | user 表示该文件的所有者                                   |\n| g               | group 表示与该文件的所有者属于同一组( group )者，即用户组 |\n| o               | other 表示其他以外的人                                    |\n| a               | all 表示这三者皆是                                        |\n\n| **[ +-= ]** | **含义** |\n| ----------- | -------- |\n| +           | 增加权限 |\n| -           | 撤销权限 |\n| =           | 设定权限 |\n\n\n\n\n', '2023-03-04 21:54:29', NULL, 'Linux', NULL, NULL, NULL);
INSERT INTO `article` VALUES (47, 'Vim的使用', '### 命令模式：\n\n用户刚刚启动 vi/vim，便进入了命令模式。\n\n此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。\n\n以下是常用的几个命令：\n\n- **i** 切换到输入模式，以输入字符。\n- **x** 删除当前光标所在处的字符。\n- **:** 切换到底线命令模式，以在最底一行输入命令。\n\n若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。\n\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n\n### 输入模式\n\n在命令模式下按下i就进入了输入模式。\n\n在输入模式中，可以使用以下按键：\n\n- **字符按键以及Shift组合**，输入字符\n- **ENTER**，回车键，换行\n- **BACK SPACE**，退格键，删除光标前一个字符\n- **DEL**，删除键，删除光标后一个字符\n- **方向键**，在文本中移动光标\n- **HOME**/**END**，移动光标到行首/行尾\n- **Page Up**/**Page Down**，上/下翻页\n- **Insert**，切换光标为输入/替换模式，光标将变成竖线/下划线\n- **ESC**，退出输入模式，切换到命令模式\n\n### 底线命令模式\n\n在命令模式下按下:（英文冒号）就进入了底线命令模式。\n\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\n- q 退出程序\n- w 保存文件\n\n------\n\n\n\n### 常用命令\n\n==一般模式下==\n\n| **[Ctrl] + [f]** | **屏幕『向下』移动一页，相当于 [Page Down]按键**   |\n| ---------------- | -------------------------------------------------- |\n| **[Ctrl] + [b]** | **屏幕『向上』移动一页，相当于 [Page Up] 按键**    |\n| **0 或 [Home]**  | **这是数字『 0 』：移动到这一行的最前面字符处**    |\n| **$ 或 [End]**   | **移动到这一行的最后面字符处**                     |\n| **G**            | **移动到这个档案的最后一行**                       |\n| **gg**           | **移动到这个档案的第一行，相当于 1G 啊！**         |\n| **n<Enter>**     | **n 为数字。光标向下移动 n 行**                    |\n| **/word**        | **向光标之下寻找一个名称为 word 的字符串**         |\n| **?word**        | **向光标之上寻找一个字符串名称为 word 的字符串。** |\n| **n**            | **在查找字符串中，移到下一个（N则上移）next**      |\n\n**删除、复制与贴上**\n\n| **x**        | **删除后一个字符，相当于delete，X是什么意思不用多说了**      |\n| ------------ | ------------------------------------------------------------ |\n| **dd**       | **剪切游标所在的那一整行，用 p/P 可以粘贴。**                |\n| **ndd**      | **n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行** |\n| **yy**       | **复制游标所在的那一行**                                     |\n| **nyy**      | **n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行** |\n| **p, P**     | **p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！** |\n| **u**        | **复原前一个动作。**                                         |\n| **[Ctrl]+r** | **重做上一个动作。**                                         |\n| **.**        | **不要怀疑！这就是小数点！意思是重复前一个动作的意思。**     |\n\n==冒号模式下==\n\n| :w!         | 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ |\n| ----------- | ------------------------------------------------------------ |\n| **:wq**     | **储存后离开，若为 :wq! 则为强制储存后离开 (常用)**          |\n| **:q!**     | **若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。** |\n| :set number | 显示行号                                                     |\n\n\n\n**ctrl** + **n**：自动补全英文单词；好东西！', '2023-03-04 21:57:41', NULL, 'Linux', NULL, NULL, NULL);
INSERT INTO `article` VALUES (48, 'Linux各目录作用', '- **/bin**：\n  bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。\n\n- **/boot：**\n  这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。\n\n- **/dev ：**\n  dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。\n\n- **/etc：**\n  etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。\n\n- **/home**：\n  用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。\n\n- **/lib**：\n  lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。\n\n- **/lost+found**：\n  这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\n\n- **/media**：\n  linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。\n\n- **/mnt**：\n  系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。\n\n- **/opt**：\n  opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。\n\n- **/proc**：\n  proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。\n  这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：\n\n  ```\n  echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all\n  ```\n\n- **/root**：\n  该目录为系统管理员，也称作超级权限者的用户主目录。\n\n- **/sbin**：\n  s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。\n\n- **/selinux**：\n  这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。\n\n- **/srv**：\n  该目录存放一些服务启动之后需要提取的数据。\n\n- **/sys**：\n\n  这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。\n\n  sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。\n\n  该文件系统是内核设备树的一个直观反映。\n\n  当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\n\n- **/tmp**：\n  tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。\n\n- **/usr**：\n  usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。\n\n- **/usr/bin：**\n  系统用户使用的应用程序。\n\n- **/usr/sbin：**\n  超级用户使用的比较高级的管理程序和系统守护程序。\n\n- **/usr/src：**\n  内核源代码默认的放置目录。\n\n- **/var**：\n  var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n\n- **/run**：\n  是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。\n\n在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。\n\n**/etc**： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。\n\n**/bin, /sbin, /usr/bin, /usr/sbin**: 这是系统预设的执行文件的放置目录，比如 **ls** 就是在 **/bin/ls** 目录下的。\n\n值得提出的是 **/bin**、**/usr/bin** 是给系统用户使用的指令（除 root 外的通用用户），而/sbin, /usr/sbin 则是给 root 使用的指令。\n\n**/var**： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。\n\n', '2023-03-04 21:58:19', NULL, 'Linux', NULL, NULL, NULL);
INSERT INTO `article` VALUES (49, 'Linux环境变量', '在Linux系统中有个变量叫做**PATH**,这个变量中是一组路径的集合,当你输入一个命令的时候(如ls),他就在这个变量的内容中给出的目录里,寻找是否有对应名称的文件,然后运行它.\n\n环境变量是用冒号分割的！！\n添加环境变量：\n```shell\necho $PATH\nPATH=${PATH}:/root\necho $PATH\n```\n\n\n\n**但是上述方法只是临时有效的。。。**\n\n**一般是修改 /etc/profile 文件来添加环境变量的！**\n\n```shell\nvim /etc/profile \nexport PATH=$PATH:/redis-4.0.9/src  	# $PATH :表示将此路径追加到系统的环境变量\nsource /etc/profile						# 修改文件后要想马上生效还要运行source不然只能在下次重进此用户时生效。\n```\n\n\n\nredis-cli -p 8003 cluster replicate 896b25f843a42ebbd86d2545269874ef16bac690\n\nredis-cli -p 8004 cluster replicate caae8f861e52042c5d84bb3318057b01ce182c36\n\nredis-cli -p 8005 cluster replicate 9bc5e41cc0bc50b870fc965f663d24d8a15b2069\n\n\n\n文件权限的rwx三种权限中，x是执行权限，如果声明了x，则代表是可执行文件。如果没有x系统就认为他不是可执行的，就算设置了环境变量也一样！\n\n如果一个脚本文件有了\"x\"权限同时又在第一行指定了对应的解释器,或者一个二进制文件有\"X\"权限,那么这个文件就成了系统认可的 可执行文件.这时候运行它不但可以指定绝对路径或者相对路径,也能通过他的解释器去执行他,更或者可以把它所在的目录加入到\"PATH\"这个变量中.\n\n如果一个脚本文件不符合上面的要求,那你只能通过他的解释器去执行他,如\"bash hello.sh\"或者\"python hello.py\"这种方式.', '2023-03-04 22:00:53', NULL, 'Linux', NULL, NULL, NULL);
INSERT INTO `article` VALUES (50, 'Redis五种数据类型', 'Redis不区分大小写\nselect x：选择x号库，redis默认16个库 【0-15】\ndbsize：查看有多少key\nTTL + key ：time to live 存活时间\nEXPIRE + key + time ：给key设置过期时间\nFLUSHDB：清空当前库\nFLUSHALL：清空所有库\ntype + key：判断类型\nkeys *：查看所有key\nexists key：查询key是否存在\n### String\n\n`String是最基本的类型，而且string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。从内部实现来看其实 string 可以看作 byte 数组，最大上限是 1G 字节。`\n\nAppend + key + xxx ：追加字符串\nstrlen：查询字符串长度\nincr key：加1 (decr减1)\nincrby + key + xx：加xx\ngetRange + key x x：截取字符串x到x (setRange替换)\nsetnx + key + value：set if not exist 不存在则创建key\nmset：批量创建key(mget 批量获得)\n\n### List\n\nLPUSH + listName + 元素：添加元素（RPUSH：反方向添加元素）\nLRANGE\nLPOP：移除元素（RPOP）\nLindex：获取指定位置的值\nLlen：获取长度\nLrem：移除指定的值\nLtrim：截掉指定长度\nRpopLpush list1 list2：将list1的最后一个移到list2的第一个\nLset：替换指定下标的值（列表该下标需存在值）\nLINSETRT + key + BEFORE|AFTER + pivot	 + value：在某个值的前面或后面插入一个值	\n\n### Set\n\n`set是无序集合，最大可以包含(2的 32 次方-1)个元素。set 的是通过 hash table 实现的，所以添加，删除，查找的复杂度都是 O(1)。hash table 会随着添加或者删除自动的调整大小。需要注意的是调整 hash table 大小时候需要同步（获取写锁）会阻塞其他读写操作。可能不久后就会改用跳表（skip list）来实现。跳表已经在 sorted sets 中使用了。关于 set 集合类型除了基本的添加删除操作，其它有用的操作还包含集合的取并集(union)，交集(intersection)，差集(difference)。通过这些操作可以很容易的实现 SNS 中的好友推荐和 blog 的 tag 功能。`\n\n不可重复\nsadd + setName + value：添加元素\nsmembers + setName：查看所有元素\nsismember：判断元素是否存在\nscard：获取set中的元素个数	\nsrem：移除指定元素\nsrandMember：随机抽取一个元素\nspop：随机移除一个元素\nsmove + set1 + set2 +value：将1中指定的值移到2\nsdiff + set1 +set2：集合差集（以set1为主）\nsinter：交集 ； sunion：并集\n\n### Hash\n\nkey <filed，value>\nhset hashName 名字 张三：在myhash中存一个键值对！\nhget + hashName + filed：获得某个Hash中的某个filed字段的value！\nhmget：获取多个（hmset设置多个）\nhgetall：获取所有\nhdel + hashName + filed：删除指定的\nhlen：长度\nhkeys + hashName：获取所有的 filed（hvals所有的值）\nhINCRBY + hashname + filed + xx ：指定增加xx\n\n### Zset\n\n带排序的set\nzadd + setName + score + value：添加一个值，带一个排序用的score\nzrangebyscore  setName  -inf  +inf [withscores] ：显示所有的值，从小到大\nzRem：移除\nzcard：获取元素个数\n\n### 应用场景\n\n	bitmaps：二进制位进行记录，一般都是记录2种状态\n\n比如365天签到，可以设置365个0，签到一天就设置为1。\n优点在于占用内存少！\nsetbit sign 0 1 ; setbit sign 0 0 ; setbit sign 0 0 ; setbit sign 0 0 ……\ngetbit sign 3 返回0，说明第4天未打卡！\n数据结构要用来解决实际的问题！！！不要单纯的使用new对象。\n\n设置bitmap中的值，指定offset，即下标，从0开始。                                                                                                   setbit  <key>  <offset>  <value>\n\n获取bitmap的值,指定offset下标，有则返回1，没有则返回0，不存在的下标也返回0。                                               getbit  <key>  <offset>\n\n统计设置为1的bit数量，可以指定获取的范围。                                                                                                           bitcount <key> [start end]\n\n**不要认为 start 和 end 是对应的bitmap的下标**，这里的start和end是按字节算的！！！\n\n\n\n', '2023-03-04 22:02:15', NULL, 'Redis', NULL, NULL, NULL);
INSERT INTO `article` VALUES (51, '单例模式', '**饿汉式**\n\n```java\npublic class Singleton{\n  ``private static Singleton singleton = ``new` `Singleton();\n  ``private Singleton(){\n  ``}\n  ``public static Singleton getInstance(){\n    ``return` `singleton;\n  ``}\n}\n```\n\n**懒汉式**\n\n```java\npublic class Singleton { \n  ``/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */\n  ``private static Singleton instance = ``null``; \n \n  ``/* 私有构造方法，防止被实例化 */\n  ``private Singleton() {} \n \n  ``/* 1:懒汉式，静态工程方法，创建实例 */\n  ``public static Singleton getInstance() { \n    ``if` `(instance == ``null``) { \n      ``instance = ``new` `Singleton(); \n    ``} \n    ``return` `instance; \n  ``} \n```\n\n**双重线程检查模式**\n\n```java\npublic class SingletonInner { \n  ``private static volatile SingletonInner sInst = ``null``; ``// <<< 这里添加了 volatile \n  ``/** \n   ``* 私有的构造函数 \n   ``*/\n  ``private SingletonInner() {} \n \n  ``public static SingletonInner getInstance() { \n    ``if` `(inst == ``null``) {      synchronized (SingletonInner.class) {``if` `(inst == ``null``) {\n          ``sInst = ``new` `SingletonInner();\n        ``}\n      ``}\n    ``}    ``return` `sInst; \n  ``} \n}\n```\n\n', '2023-03-04 22:56:33', NULL, 'JAVA', NULL, NULL, NULL);
INSERT INTO `article` VALUES (52, 'Synchroized关键字', '##作用在方法上\n```java\n	//作用在普通方法上，锁的是调用者这个对象，多new几个对象，互相没有锁的约束\n	public synchronized void a(){\n		xxx;\n	}\n	//作用在static方法上，锁的是类，new 多个对象也同一时间也只有一条线程能访问。\n	public static synchronized void b(){\n		xxx;\n	}\n	\n```\n\n##代码块\n```java\npublic class Test{\n\n	public static int i;\n	public int j;\n\n	public void a(){\n		xxx;\n		/*必须填参数，且只能填对象，比如这个int j就不行\n		且方法是静态方法就只能锁静态的资源，如果这是个 static void a()；\n		就没法锁this————调用者这个对象，或者非静态的属性\n		*/\n		synchronized(this){\n			xxx;\n		}\n		xxx;\n	}\n}\n\n```', '2023-03-04 23:15:48', NULL, 'JAVA', NULL, NULL, NULL);

SET FOREIGN_KEY_CHECKS = 1;
